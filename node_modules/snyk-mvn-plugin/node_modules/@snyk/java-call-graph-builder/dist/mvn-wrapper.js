"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClassPathFromMvn = exports.mergeMvnClassPaths = exports.parseMvnExecCommandOutput = exports.parseMvnDependencyPluginCommandOutput = exports.getMvnCommandArgsForMvnExec = exports.buildFullClassPath = void 0;
const tslib_1 = require("tslib");
require("source-map-support/register");
const sub_process_1 = require("./sub-process");
const errors_1 = require("./errors");
const fs = require("fs");
const path = require("path");
const tmp = require("tmp");
const debug_1 = require("./debug");
const os = require('os');
function runCommandWithOutputToFile(f) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // NOTE(alexmu): We have to do this little dance with output written to files
        // because that seems to be the only way to get the output without having to
        // parse maven logs
        const outputName = tmp.tmpNameSync();
        try {
            yield f(outputName);
            return fs.readFileSync(outputName, 'utf8');
        }
        catch (error) {
            debug_1.debug(`Failed to execute command. ${error}`);
            throw error;
        }
        finally {
            try {
                fs.unlinkSync(outputName);
            }
            catch (error) {
                debug_1.debug(`unlinkSync failed. ${error}`);
            }
        }
    });
}
function getDependenciesClassPath(targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return runCommandWithOutputToFile((outputFile) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sub_process_1.execute('mvn', [
                'dependency:build-classpath',
                `-Dmdep.outputFile=${outputFile}`,
                '-f',
                targetPath,
            ], { cwd: targetPath });
        }));
    });
}
function getOutputDirectory(targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return runCommandWithOutputToFile((outputFile) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sub_process_1.execute('mvn', [
                'help:evaluate',
                '-Dexpression="project.build.outputDirectory"',
                `-Doutput=${outputFile}`,
                '-f',
                targetPath,
            ], { cwd: targetPath });
        }));
    });
}
function buildFullClassPath(dependenciesClassPath, outputDirectory) {
    if (dependenciesClassPath.length === 0) {
        debug_1.debug('Failed to determine the dependencies classpath.');
    }
    if (outputDirectory.length === 0) {
        debug_1.debug('Failed to determine the project output directory.');
    }
    const sanitisedOutputDirectory = outputDirectory.trim();
    let sanitisedClassPath = dependenciesClassPath.trim();
    while (sanitisedClassPath.endsWith(path.delimiter)) {
        sanitisedClassPath = sanitisedClassPath.slice(0, -1);
    }
    if (sanitisedClassPath.length === 0) {
        return sanitisedOutputDirectory;
    }
    else if (sanitisedOutputDirectory.length === 0) {
        return sanitisedClassPath;
    }
    else {
        return `${sanitisedClassPath}${path.delimiter}${sanitisedOutputDirectory}`;
    }
}
exports.buildFullClassPath = buildFullClassPath;
// NOTE(alexmu): This is deprecated, and will be removed in the future
function getMvnCommandArgsForMvnExec(targetPath) {
    return process.platform === 'win32'
        ? [
            '-q',
            'exec:exec',
            '-Dexec.classpathScope="compile"',
            '-Dexec.executable="cmd"',
            '-Dexec.args="/c echo %classpath"',
            '-f',
            targetPath,
        ]
        : [
            '-q',
            'exec:exec',
            '-Dexec.classpathScope="compile"',
            '-Dexec.executable="echo"',
            '-Dexec.args="%classpath"',
            '-f',
            targetPath,
        ];
}
exports.getMvnCommandArgsForMvnExec = getMvnCommandArgsForMvnExec;
// NOTE(alexmu): This is deprecated, and will be removed in the future
function getMvnCommandArgsForDependencyPlugin(targetPath) {
    return ['dependency:build-classpath', '-f', targetPath];
}
// NOTE(alexmu): This is deprecated, and will be removed in the future
function parseMvnDependencyPluginCommandOutput(mvnCommandOutput) {
    const outputLines = mvnCommandOutput.split(os.EOL);
    const mvnClassPaths = [];
    let startIndex = 0;
    let i = outputLines.indexOf('[INFO] Dependencies classpath:', startIndex);
    while (i > -1) {
        if (outputLines[i + 1] !== '') {
            mvnClassPaths.push(outputLines[i + 1]);
        }
        startIndex = i + 2;
        i = outputLines.indexOf('[INFO] Dependencies classpath:', startIndex);
    }
    return mvnClassPaths;
}
exports.parseMvnDependencyPluginCommandOutput = parseMvnDependencyPluginCommandOutput;
// NOTE(alexmu): This is deprecated, and will be removed in the future
function parseMvnExecCommandOutput(mvnCommandOutput) {
    return mvnCommandOutput.trim().split(os.EOL);
}
exports.parseMvnExecCommandOutput = parseMvnExecCommandOutput;
// NOTE(alexmu): This is deprecated, and will be removed in the future
function mergeMvnClassPaths(classPaths) {
    // this magic joins all items in array with :, splits result by : again
    // makes Set (to uniq items), create Array from it and join it by : to have
    // proper path like format
    return Array.from(new Set(classPaths.join(':').split(':'))).join(':');
}
exports.mergeMvnClassPaths = mergeMvnClassPaths;
// NOTE(alexmu): This is deprecated, and will be removed in the future
function getClassPathFromMvnLegacy(targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let classPaths = [];
        let args = [];
        try {
            try {
                // there are two ways of getting classpath - either from maven plugin or by exec command
                // try `mvn exec` for classpath
                args = getMvnCommandArgsForMvnExec(targetPath);
                const output = yield sub_process_1.execute('mvn', args, { cwd: targetPath });
                classPaths = parseMvnExecCommandOutput(output);
            }
            catch (e) {
                // if it fails, try mvn dependency:build-classpath
                // TODO send error message for further analysis
                args = getMvnCommandArgsForDependencyPlugin(targetPath);
                const output = yield sub_process_1.execute('mvn', args, { cwd: targetPath });
                classPaths = parseMvnDependencyPluginCommandOutput(output);
            }
        }
        catch (e) {
            throw new errors_1.ClassPathGenerationError(e);
        }
        if (classPaths.length === 0) {
            throw new errors_1.EmptyClassPathError(`mvn ${args.join(' ')}`);
        }
        return mergeMvnClassPaths(classPaths);
    });
}
function getClassPathFromMvn(targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const [dependenciesClassPath, outputDirectory] = yield Promise.all([
                getDependenciesClassPath(targetPath),
                getOutputDirectory(targetPath),
            ]);
            const fullClassPath = buildFullClassPath(dependenciesClassPath, outputDirectory);
            if (fullClassPath.length === 0) {
                throw new errors_1.EmptyClassPathError('mvn');
            }
            return fullClassPath;
        }
        catch (e) {
            // NOTE(alexmu): Fall back to the legacy method of determining the classpath
            debug_1.debug(`Failed to determine the classpath using the new method. Falling back to the legacy method. ${e}`);
            return getClassPathFromMvnLegacy(targetPath);
        }
    });
}
exports.getClassPathFromMvn = getClassPathFromMvn;
//# sourceMappingURL=mvn-wrapper.js.map